"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  spawn: () => spawn
});
module.exports = __toCommonJS(src_exports);

// src/inject.ts
var import_url = require("url");
var import_meta_url = (0, import_url.pathToFileURL)(__filename);

// src/index.ts
var import_path = require("path");
var import_worker_threads = require("worker_threads");

// chrome-cxx/mnt/extension/WasmTypes.js
function serializeWasmValue(value, buffer) {
  if (value instanceof ArrayBuffer) {
    const data = new Uint8Array(value);
    new Uint8Array(buffer).set(data);
    return data.byteLength || -1;
  }
  const view = new DataView(buffer);
  switch (value.type) {
    case "i32":
      view.setInt32(0, value.value, true);
      return 1;
    case "i64":
      view.setBigInt64(0, value.value, true);
      return 2;
    case "f32":
      view.setFloat32(0, value.value, true);
      return 3;
    case "f64":
      view.setFloat64(0, value.value, true);
      return 4;
    case "v128":
      const [enc, a, b, c, d] = value.value.split(" ");
      view.setInt32(0, Number(a), true);
      view.setInt32(4, Number(b), true);
      view.setInt32(8, Number(c), true);
      view.setInt32(12, Number(d), true);
      return 5;
    default:
      throw new Error("cannot serialize non-numerical wasm type");
  }
}
var kMaxWasmValueSize = 4 + 4 + 4 * 10;

// chrome-cxx/mnt/extension/WorkerRPC.js
var SynchronousIOMessage = class {
  buffer;
  constructor(bufferSize) {
    this.buffer = new SharedArrayBuffer(bufferSize);
  }
  static serialize(value, buffer) {
    return serializeWasmValue(value, buffer);
  }
};
var WorkerRPC = class {
  nextRequestId = 0;
  channel;
  localHandler;
  requests = /* @__PURE__ */ new Map();
  semaphore;
  constructor(channel, localHandler) {
    this.channel = channel;
    this.channel.onmessage = this.onmessage.bind(this);
    this.localHandler = localHandler;
    this.semaphore = new Int32Array(new SharedArrayBuffer(4));
  }
  sendMessage(method, ...params) {
    const requestId = this.nextRequestId++;
    const promise = new Promise((resolve, reject) => {
      this.requests.set(requestId, { resolve, reject });
    });
    this.channel.postMessage({ requestId, request: { method, params } });
    return promise;
  }
  sendMessageSync(message, method, ...params) {
    const requestId = this.nextRequestId++;
    Atomics.store(this.semaphore, 0, 0);
    this.channel.postMessage({
      requestId,
      sync_request: {
        request: { method, params },
        io_buffer: { semaphore: this.semaphore.buffer, data: message.buffer }
      }
    });
    while (Atomics.wait(this.semaphore, 0, 0) !== "not-equal") {
    }
    const [response] = this.semaphore;
    return message.deserialize(response);
  }
  async onmessage(event) {
    if ("request" in event.data) {
      const { requestId, request } = event.data;
      try {
        const response = await this.localHandler[request.method](...request.params);
        this.channel.postMessage({ requestId, response });
      } catch (error) {
        this.channel.postMessage({ requestId, error: `${error}` });
      }
    } else if ("sync_request" in event.data) {
      const { sync_request: { request, io_buffer } } = event.data;
      let signal = -1;
      try {
        const response = await this.localHandler[request.method](...request.params);
        signal = SynchronousIOMessage.serialize(response, io_buffer.data);
      } catch (error) {
        throw error;
      } finally {
        const semaphore = new Int32Array(io_buffer.semaphore);
        Atomics.store(semaphore, 0, signal);
        Atomics.notify(semaphore, 0);
      }
    } else {
      const { requestId } = event.data;
      const callbacks = this.requests.get(requestId);
      if (callbacks) {
        const { resolve, reject } = callbacks;
        if ("error" in event.data) {
          reject(new Error(event.data.error));
        } else {
          resolve(event.data.response);
        }
      }
    }
  }
};

// src/index.ts
function spawn(hostInterface) {
  const worker = new import_worker_threads.Worker((0, import_path.join)(__dirname, "worker.js"));
  worker.on("message", (data) => channel.onmessage?.(new MessageEvent("message", { data })));
  const channel = {
    onmessage: null,
    postMessage: (m) => worker.postMessage(m)
  };
  const rpc = new WorkerRPC(channel, hostInterface);
  return {
    rpc,
    dispose: async () => {
      await worker.terminate();
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  spawn
});
